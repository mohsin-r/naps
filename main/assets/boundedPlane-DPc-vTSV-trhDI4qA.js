import{g_ as E,cD as U,cI as u,hi as l,cC as p,dH as st,cH as P,cE as at,hm as I,cL as rt,cK as ct,cJ as m,cN as O,eJ as V,ef as ut,eF as gt,eq as h,ij as bt,ik as x,cO as R,ih as H,cB as M,Q as ft}from"./main-B2UX4EBG.js";import{B as j,p as lt}from"./sphere-_Zcui0FU-DWMKiHse.js";import{t as z}from"./mat4f64-Dn1WEGBx-C99QVUMW.js";import{u as pt,p as L,h as dt}from"./lineSegment-CMEPBlyR-BiyqhvqX.js";import{B as v,b as ht,$ as mt,T as A,f as a,k as It,M as Nt,S as Pt,m as Mt,g as J,D as Tt,P as T,N as S,h as St}from"./plane-B2J4G_40-Dg370CQZ.js";const C=()=>ft.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");class _t{constructor(){this.plane=v(),this.origin=M(),this.basis1=M(),this.basis2=M()}}const vt=_t;function N(t=ot){return{plane:v(t.plane),origin:U(t.origin),basis1:U(t.basis1),basis2:U(t.basis2)}}function wt(t,i,n){const e=Rt.get();return e.origin=t,e.basis1=i,e.basis2=n,e.plane=ht(0,0,0,0),B(e),e}function w(t,i=N()){return G(t.origin,t.basis1,t.basis2,i)}function Bt(t,i){u(i.origin,t.origin),u(i.basis1,t.basis1),u(i.basis2,t.basis2),mt(i.plane,t.plane)}function G(t,i,n,e=N()){return u(e.origin,t),u(e.basis1,i),u(e.basis2,n),B(e),Dt(e,"fromValues()"),e}function B(t){A(t.basis2,t.basis1,t.origin,t.plane)}function X(t,i,n){t!==n&&w(t,n);const e=l(a.get(),f(t),i);return p(n.origin,n.origin,e),n.plane[3]-=i,n}function yt(t,i,n){return K(i,n),X(n,q(t,t.origin),n),n}function Et(t,i){const n=t.basis1[0],e=t.basis2[1],[o,s]=t.origin;return st(o-n,s-e,o+n,s+e,i)}function K(t,i=N()){const n=(t[2]-t[0])/2,e=(t[3]-t[1])/2;return P(i.origin,t[0]+n,t[1]+e,0),P(i.basis1,n,0,0),P(i.basis2,0,e,0),It(0,0,1,0,i.plane),i}function k(t,i,n){return!!Nt(t.plane,i,n)&&it(t,n)}function Ut(t,i,n){if(k(t,i,n))return n;const e=W(t,i,a.get());return p(n,i.origin,l(a.get(),i.direction,at(i.origin,e)/I(i.direction))),n}function W(t,i,n){const e=_.get();et(t,i,e,_.get());let o=Number.POSITIVE_INFINITY;for(const s of Y){const r=D(t,s,y.get()),g=a.get();if(Pt(e,r,g)){const c=rt(a.get(),i.origin,g),b=Math.abs(ct(m(i.direction,c)));b<o&&(o=b,u(n,g))}}return o===Number.POSITIVE_INFINITY?Z(t,i,n):n}function Vt(t,i){return(i-t)/i}function Z(t,i,n){if(k(t,i,n))return n;const e=_.get(),o=_.get();et(t,i,e,o);let s=Number.POSITIVE_INFINITY;for(const r of Y){const g=D(t,r,y.get()),c=a.get();if(Mt(e,g,c)){const b=lt(i,c);if(!J(o,c))continue;b<s&&(s=b,u(n,c))}}return F(t,i.origin)<s&&tt(t,i.origin,n),n}function tt(t,i,n){const e=Tt(t.plane,i,a.get()),o=L(Q(t,t.basis1),e,-1,1,a.get()),s=L(Q(t,t.basis2),e,-1,1,a.get());return O(n,p(a.get(),o,s),t.origin),n}function nt(t,i,n){const{origin:e,basis1:o,basis2:s}=t,r=O(a.get(),i,e),g=T(o,r),c=T(s,r),b=T(f(t),r);return P(n,g,c,b)}function F(t,i){const n=nt(t,i,a.get()),{basis1:e,basis2:o}=t,s=I(e),r=I(o),g=Math.max(Math.abs(n[0])-s,0),c=Math.max(Math.abs(n[1])-r,0),b=n[2];return g*g+c*c+b*b}function xt(t,i){return Math.sqrt(F(t,i))}function Ct(t,i){let n=Number.NEGATIVE_INFINITY;for(const e of Y){const o=D(t,e,y.get()),s=dt(o,i);s>n&&(n=s)}return Math.sqrt(n)}function $t(t,i){return J(t.plane,i)&&it(t,i)}function At(t,i,n,e){return qt(t,n,e)}function q(t,i){const n=-t.plane[3];return T(f(t),i)-n}function Ot(t,i,n,e){const o=q(t,i),s=l(Yt,f(t),n-o);return p(e,i,s),e}function jt(t,i){return V(t.basis1,i.basis1)&&V(t.basis2,i.basis2)&&V(t.origin,i.origin)}function kt(t,i,n){return t!==n&&w(t,n),ut(d,i),gt(d,d),h(n.basis1,t.basis1,d),h(n.basis2,t.basis2,d),h(S(n.plane),S(t.plane),d),h(n.origin,t.origin,i),St(n.plane,n.plane,n.origin),n}function Ft(t,i,n,e){return t!==e&&w(t,e),bt($,i,n),h(e.basis1,t.basis1,$),h(e.basis2,t.basis2,$),B(e),e}function f(t){return S(t.plane)}function qt(t,i,n){switch(i){case x.X:u(n,t.basis1),R(n,n);break;case x.Y:u(n,t.basis2),R(n,n);break;case x.Z:u(n,f(t))}return n}function it(t,i){const n=O(a.get(),i,t.origin),e=H(t.basis1),o=H(t.basis2),s=m(t.basis1,n),r=m(t.basis2,n);return-s-e<0&&s-e<0&&-r-o<0&&r-o<0}function Q(t,i){const n=y.get();return u(n.origin,t.origin),u(n.vector,i),n}function D(t,i,n){const{basis1:e,basis2:o,origin:s}=t,r=l(a.get(),e,i.origin[0]),g=l(a.get(),o,i.origin[1]);p(n.origin,r,g),p(n.origin,n.origin,s);const c=l(a.get(),e,i.direction[0]),b=l(a.get(),o,i.direction[1]);return l(n.vector,p(c,c,b),2),n}function Dt(t,i){Math.abs(m(t.basis1,t.basis2)/(I(t.basis1)*I(t.basis2)))>1e-6&&C().warn(i,"Provided basis vectors are not perpendicular"),Math.abs(m(t.basis1,f(t)))>1e-6&&C().warn(i,"Basis vectors and plane normal are not perpendicular"),Math.abs(-m(f(t),t.origin)-t.plane[3])>1e-6&&C().warn(i,"Plane offset is not consistent with plane origin")}function et(t,i,n,e){const o=f(t);A(o,i.direction,i.origin,n),A(S(n),o,i.origin,e)}const ot={plane:v(),origin:E(0,0,0),basis1:E(1,0,0),basis2:E(0,1,0)},_=new j(v),y=new j(pt),Yt=M(),Rt=new j(()=>N()),Y=[{origin:[-1,-1],direction:[1,0]},{origin:[1,-1],direction:[0,1]},{origin:[1,1],direction:[-1,0]},{origin:[-1,1],direction:[0,-1]}],d=z(),$=z(),Gt=Object.freeze(Object.defineProperty({__proto__:null,BoundedPlaneClass:vt,altitudeAt:q,axisAt:At,cameraFrustumCoverage:Vt,closestPoint:Z,closestPointOnSilhouette:W,copy:w,copyWithoutVerify:Bt,create:N,distance:xt,distance2:F,distanceToSilhouette:Ct,elevate:X,equals:jt,extrusionContainsPoint:$t,fromAABoundingRect:K,fromValues:G,getExtent:Et,intersectRay:k,intersectRayClosestSilhouette:Ut,normal:f,projectPoint:tt,projectPointLocal:nt,rotate:Ft,setAltitudeAt:Ot,setExtent:yt,transform:kt,up:ot,updateUnboundedPlane:B,wrap:wt},Symbol.toStringTag,{value:"Module"}));export{Gt as H,w as M,B as N,N as h,G as j};
